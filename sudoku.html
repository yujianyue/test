<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>数独分步解独工具</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f5f5f5;
      --fg: #222;
      --accent: #0d6efd;
      --danger: #d6336c;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--fg);
      line-height: 1.6;
    }

    h1 {
      margin: 0 0 16px;
      font-size: 28px;
    }

    p {
      margin: 0 0 12px;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(320px, auto) minmax(240px, 1fr);
      gap: 24px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
    }

    button {
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 6px;
      padding: 6px 14px;
      font-size: 14px;
      cursor: pointer;
      background: white;
      color: inherit;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }

    button:hover,
    button:focus-visible {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    button.danger:hover,
    button.danger:focus-visible {
      background: var(--danger);
      border-color: var(--danger);
    }

    textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 8px;
      font-family: "Iosevka", "Fira Code", monospace;
      resize: vertical;
      background: white;
      color: inherit;
    }

    label {
      font-weight: 600;
      display: block;
      margin-bottom: 6px;
    }

    .board-wrapper {
      padding: 12px;
      border-radius: 12px;
      background: white;
      border: 1px solid rgba(0, 0, 0, 0.1);
      position: relative;
      display: inline-block;
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
    }

    .share-row {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .share-row input {
      flex: 1 1 220px;
      padding: 6px 10px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      border-radius: 6px;
      font-size: 14px;
      background: white;
      color: inherit;
    }

    .digit-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .digit-panel button {
      width: 40px;
      text-align: center;
    }

    .digit-panel button[data-digit="0"] {
      flex: 1 0 80px;
    }

    .steps-container {
      margin-top: 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .step-card {
      padding: 16px;
      border-radius: 12px;
      background: white;
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .step-card h2 {
      margin: 0 0 12px;
      font-size: 18px;
    }

    .step-card canvas {
      width: 100%;
      height: auto;
    }

    .status {
      margin-top: 12px;
      font-size: 14px;
      color: rgba(0, 0, 0, 0.6);
    }

    footer {
      margin-top: 32px;
      font-size: 13px;
      color: rgba(0, 0, 0, 0.55);
    }

    @media (max-width: 980px) {
      body {
        padding: 16px;
      }

      .layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <h1>数独分步解独工具</h1>
  <p>该工具基于候选数筛选和高级链式技巧，能够逐步演示数独的解题过程。你可以手动录入题目、执行单步推理，或一键自动求解全局。</p>

  <div class="layout">
    <section>
      <div class="toolbar">
        <button id="btn-reset" class="danger">清空棋盘</button>
        <button id="btn-example">导入示例</button>
        <button id="btn-edit">进入编辑模式</button>
        <button id="btn-step">执行单步</button>
        <button id="btn-solve">自动求解</button>
        <button id="btn-step-clear">清空解析记录</button>
      </div>

      <div class="board-wrapper">
        <canvas id="board" width="666" height="666">Canvas not supported.</canvas>
      </div>

      <div class="digit-panel" id="digit-panel" hidden>
        <button data-digit="1">1</button>
        <button data-digit="2">2</button>
        <button data-digit="3">3</button>
        <button data-digit="4">4</button>
        <button data-digit="5">5</button>
        <button data-digit="6">6</button>
        <button data-digit="7">7</button>
        <button data-digit="8">8</button>
        <button data-digit="9">9</button>
        <button data-digit="0">清空</button>
      </div>

      <div class="share-row">
        <button id="btn-share">生成分享链接</button>
        <input id="share-link" type="text" readonly placeholder="链接将显示在这里">
      </div>

      <p class="status" id="status-text">编辑模式：可以点击棋盘录入题目。</p>
    </section>

    <section>
      <label for="puzzle-input">批量导入（支持 0/ . 表示空，忽略非数字字符）：</label>
      <textarea id="puzzle-input" placeholder="例如：530070000600195000098000060..."></textarea>
      <div class="toolbar" style="margin-top: 12px;">
        <button id="btn-apply">应用到棋盘</button>
        <button id="btn-export">导出当前棋盘</button>
      </div>

      <div class="steps-container" id="steps"></div>
    </section>
  </div>

  <footer>
    提示：点击棋盘中的格子以选择单元，再使用下方数字面板填入数字。执行单步后将自动切换到演示模式，如需修改题目请点击“进入编辑模式”重新调整。
  </footer>

  <script>
    (function () {
      const SIZE = 9;
      const CHAR_W = 24;
      const CHAR_H = 24;
      const HALF_CHAR_W = Math.floor(CHAR_W / 2);
      const HALF_CHAR_H = Math.floor(CHAR_H / 2);
      const CELL_W = 3 * CHAR_W;
      const CELL_H = 3 * CHAR_H;
      const BOARD_W = SIZE * (1 + CELL_W);
      const BOARD_H = SIZE * (1 + CELL_H);

      const tech = {
        NakedSingle: "显性单数 (Naked Single)",
        HiddenSingle: "隐性单数 (Hidden Single)",
        Claiming: "占位排除 (Claiming)",
        Pointing: "定向排除 (Pointing)",
        NakedSubset: "显性子集 (Naked Subset)",
        HiddenSubset: "隐性子集 (Hidden Subset)",
        X_Wing: "X 翼 (X-Wing)",
        XY_Wing: "XY 翼 (XY-Wing)",
        W_Wing: "W 翼 (W-Wing)",
        XYZ_Wing: "XYZ 翼 (XYZ-Wing)",
        X_Chains: "X 链 (X-Chains)",
        XY_Chains: "XY 链 (XY-Chains)",
      };

      const tCOL = new Array(81);
      const tROW = new Array(81);
      const tBOX = new Array(81);
      for (let i = 0; i < 81; i += 1) {
        tCOL[i] = i % 9;
        tROW[i] = Math.floor(i / 9);
        tBOX[i] = 3 * Math.floor(tROW[i] / 3) + Math.floor(tCOL[i] / 3);
      }

      const COL = (i) => tCOL[i];
      const ROW = (i) => tROW[i];
      const BOX = (i) => tBOX[i];

      const boardCanvas = document.getElementById("board");
      boardCanvas.width = BOARD_W;
      boardCanvas.height = BOARD_H;
      const shareInput = document.getElementById("share-link");
      const stepsContainer = document.getElementById("steps");
      const statusText = document.getElementById("status-text");
      const puzzleInput = document.getElementById("puzzle-input");
      const digitPanel = document.getElementById("digit-panel");

      const hs_ns = "2";
      let msg = "";

      const puzzle = new Array(81).fill(0);
      const candidates = new Array(81).fill(0);
      let editMode = true;
      let selectedCell = null;

      let ht1 = [];
      let ht2 = [];
      let ht3 = [];
      let ht4 = [];
      let htMask = [];

      function n2b(n) {
        return 1 << (n - 1);
      }

      function bc(n) {
        let c = 0;
        for (let i = 0; i < 9; i += 1) {
          if (n & (1 << i)) {
            c += 1;
          }
        }
        return c;
      }

      function b2n(mask) {
        for (let i = 0; i < 9; i += 1) {
          if (mask & (1 << i)) {
            return 1 + i;
          }
        }
        return 0;
      }

      function getIdxFromColRow(col, row) {
        return 9 * row + col;
      }

      function getIdxFromBoxIdx(box, i) {
        const bcol = box % 3;
        const brow = Math.floor(box / 3);
        const ccol = i % 3;
        const crow = Math.floor(i / 3);
        return 9 * (3 * brow + crow) + 3 * bcol + ccol;
      }

      function isSolved(i) {
        return puzzle[i] !== 0;
      }

      function isSingle(candidateMask) {
        let count = 0;
        let n = 0;
        for (let i = 0; i < 9; i += 1) {
          if (candidateMask & (1 << i)) {
            count += 1;
            n = i + 1;
          }
        }
        return count === 1 ? n : 0;
      }

      function getCandidateListOfBox(box, list, idx) {
        for (let cell = 0; cell < 9; cell += 1) {
          const i = getIdxFromBoxIdx(box, cell);
          list[cell] = isSolved(i) ? 0 : candidates[i];
          idx[cell] = i;
        }
      }

      function getCandidateListOfCol(col, list, idx) {
        for (let row = 0; row < 9; row += 1) {
          const i = getIdxFromColRow(col, row);
          list[row] = isSolved(i) ? 0 : candidates[i];
          idx[row] = i;
        }
      }

      function getCandidateListOfRow(row, list, idx) {
        for (let col = 0; col < 9; col += 1) {
          const i = getIdxFromColRow(col, row);
          list[col] = isSolved(i) ? 0 : candidates[i];
          idx[col] = i;
        }
      }

      function getCandidateCountOfList(candidateList, n, cells) {
        let count = 0;
        const mask = n2b(n);
        for (let i = 0; i < 9; i += 1) {
          if (candidateList[i] & mask) {
            cells[count] = i;
            count += 1;
          }
        }
        return count;
      }

      function initCandidates() {
        for (let row = 0; row < 9; row += 1) {
          for (let col = 0; col < 9; col += 1) {
            const i = getIdxFromColRow(col, row);
            candidates[i] = isSolved(i) ? n2b(puzzle[i]) : 0x1ff;
          }
        }
        updateCandidates();
      }

      function updateCandidates() {
        for (let box = 0; box < 9; box += 1) {
          for (let cell = 0; cell < 9; cell += 1) {
            const index = getIdxFromBoxIdx(box, cell);
            if (!isSolved(index)) {
              continue;
            }
            const n = puzzle[index];
            for (let i = 0; i < 9; i += 1) {
              if (i !== cell) {
                candidates[getIdxFromBoxIdx(box, i)] &= ~n2b(n);
              }
            }
          }
        }

        for (let col = 0; col < 9; col += 1) {
          for (let row = 0; row < 9; row += 1) {
            const index = getIdxFromColRow(col, row);
            if (!isSolved(index)) {
              continue;
            }
            const n = puzzle[index];
            for (let i = 0; i < 9; i += 1) {
              if (i !== row) {
                candidates[getIdxFromColRow(col, i)] &= ~n2b(n);
              }
            }
          }
        }

        for (let row = 0; row < 9; row += 1) {
          for (let col = 0; col < 9; col += 1) {
            const index = getIdxFromColRow(col, row);
            if (!isSolved(index)) {
              continue;
            }
            const n = puzzle[index];
            for (let i = 0; i < 9; i += 1) {
              if (i !== col) {
                candidates[getIdxFromColRow(i, row)] &= ~n2b(n);
              }
            }
          }
        }
      }

      function fillCell(ctx, x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, CELL_W + 1, CELL_H + 1);
        ctx.fillStyle = "#1f1f1f";
      }

      function renderPuzzle(canvasId, { selection = null } = {}) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
          return;
        }
        const ctx = canvas.getContext("2d");

        ctx.lineWidth = 1;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, BOARD_W, BOARD_H);
        ctx.fillStyle = "#1f1f1f";

        for (let i = 0; i < 81; i += 1) {
          let x = COL(i) * (1 + CELL_W);
          let y = ROW(i) * (1 + CELL_H);

          if (selection === i) {
            fillCell(ctx, x, y, "rgba(13, 110, 253, 0.25)");
          } else if (ht1.includes(i)) {
            fillCell(ctx, x, y, "#B6FF00");
          } else if (ht2.includes(i)) {
            fillCell(ctx, x, y, "#F8FF90");
          }

          x += Math.floor(CHAR_W / 2);
          y += Math.floor(CHAR_H / 2) + 1;

          if (puzzle[i] !== 0) {
            ctx.font = "30px Arial";
            ctx.fillStyle = "#1f1f1f";
            ctx.fillText(puzzle[i], x + CHAR_W, y + CHAR_H);
          } else {
            ctx.font = CHAR_H + "px sans-serif";
            ctx.fillStyle = "#1f1f1f";
            for (let j = 0; j < 9; j += 1) {
              if (candidates[i] & n2b(1 + j)) {
                ctx.fillText(1 + j, x + (j % 3) * CHAR_W, y + Math.floor(j / 3) * CHAR_H);
              }
            }
            const htIndex = ht3.indexOf(i);
            if (htIndex !== -1 && htMask[htIndex] !== 0) {
              ctx.fillStyle = "#d6336c";
              ctx.strokeStyle = "#d6336c";
              for (let j = 0; j < 9; j += 1) {
                if (htMask[htIndex] & n2b(1 + j)) {
                  const cx = x + (j % 3) * CHAR_W;
                  const cy = y + Math.floor(j / 3) * CHAR_H;
                  ctx.fillText(1 + j, cx, cy);
                  ctx.beginPath();
                  ctx.moveTo(cx - HALF_CHAR_W, cy - HALF_CHAR_H);
                  ctx.lineTo(cx + HALF_CHAR_W, cy + HALF_CHAR_H);
                  ctx.stroke();
                }
              }
              ctx.fillStyle = "#1f1f1f";
            }
          }
        }

        for (let i = 1; i < 9; i += 1) {
          const x = i * (1 + CELL_W);
          const y = i * (1 + CELL_H);
          ctx.strokeStyle = i % 3 === 0 ? "#000000" : "#c0c0c0";
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, BOARD_H);
          ctx.moveTo(0, y);
          ctx.lineTo(BOARD_W, y);
          ctx.stroke();
        }

        ctx.strokeStyle = "#d6336c";
        for (let i = 0; i < ht4.length; i += 3) {
          const a = ht4[i];
          const b = ht4[i + 1];
          const n = ht4[i + 2] - 1;
          const xa = COL(a) * (1 + CELL_W);
          const ya = ROW(a) * (1 + CELL_H);
          const cxa = xa + (n % 3) * CHAR_W;
          const cya = ya + Math.floor(n / 3) * CHAR_H;
          const xb = COL(b) * (1 + CELL_W);
          const yb = ROW(b) * (1 + CELL_H);
          const cxb = xb + (n % 3) * CHAR_W;
          const cyb = yb + Math.floor(n / 3) * CHAR_H;
          ctx.beginPath();
          ctx.rect(cxa, cya, CHAR_W, CHAR_H);
          ctx.rect(cxb, cyb, CHAR_W, CHAR_H);
          ctx.moveTo(cxa + HALF_CHAR_W, cya + HALF_CHAR_H);
          ctx.lineTo(cxb + HALF_CHAR_W, cyb + HALF_CHAR_H);
          ctx.stroke();
        }

        ctx.strokeStyle = "#1f1f1f";

        ht1 = [];
        ht2 = [];
        ht3 = [];
        ht4 = [];
        htMask = [];
      }

      function addStep(round) {
        const name = `step-${round}`;
        const wrapper = document.createElement("article");
        wrapper.className = "step-card";

        const heading = document.createElement("h2");
        heading.textContent = `步骤 ${round}：${msg}`;
        wrapper.appendChild(heading);

        const canvas = document.createElement("canvas");
        canvas.id = name;
        canvas.width = BOARD_W;
        canvas.height = BOARD_H;
        wrapper.appendChild(canvas);

        stepsContainer.appendChild(wrapper);
        renderPuzzle(name);
      }

      function findSingle(c, idx) {
        const cell = [];
        for (let n = 1; n <= 9; n += 1) {
          if (getCandidateCountOfList(c, n, cell) !== 1) {
            continue;
          }
          const i = idx[cell[0]];
          puzzle[i] = n;
          candidates[i] = n2b(n);
          ht1.push(i);
          return true;
        }
        return false;
      }

      function p_findSingle() {
        if (hs_ns === "2") {
          for (let i = 0; i < 81; i += 1) {
            if (isSolved(i)) {
              continue;
            }
            const n = isSingle(candidates[i]);
            if (n === 0) {
              continue;
            }
            puzzle[i] = n;
            candidates[i] = n2b(n);
            ht1.push(i);
            msg = tech.NakedSingle;
            return true;
          }
        }

        msg = tech.HiddenSingle;
        const c = [];
        const idx = [];
        for (let i = 0; i < 9; i += 1) {
          getCandidateListOfBox(i, c, idx);
          if (findSingle(c, idx)) {
            ht2 = idx.slice();
            return true;
          }
          getCandidateListOfCol(i, c, idx);
          if (findSingle(c, idx)) {
            ht2 = idx.slice();
            return true;
          }
          getCandidateListOfRow(i, c, idx);
          if (findSingle(c, idx)) {
            ht2 = idx.slice();
            return true;
          }
        }

        if (hs_ns === "1") {
          for (let i = 0; i < 81; i += 1) {
            if (isSolved(i)) {
              continue;
            }
            const n = isSingle(candidates[i]);
            if (n === 0) {
              continue;
            }
            puzzle[i] = n;
            candidates[i] = n2b(n);
            ht1.push(i);
            msg = tech.NakedSingle;
            return true;
          }
        }
        return false;
      }

      function findClaiming(c, idx) {
        const cell = [];
        for (let n = 1; n <= 9; n += 1) {
          const count = getCandidateCountOfList(c, n, cell);
          if (count !== 2 && count !== 3) {
            continue;
          }
          if (count === 2) {
            cell[2] = cell[0];
          }
          if (BOX(idx[cell[0]]) !== BOX(idx[cell[1]]) || BOX(idx[cell[0]]) !== BOX(idx[cell[2]])) {
            continue;
          }
          const c2 = [];
          const idx2 = [];
          getCandidateListOfBox(BOX(idx[cell[0]]), c2, idx2);
          let changed = false;
          const mask = n2b(n);
          for (let i = 0; i < 9; i += 1) {
            const index = idx2[i];
            if (isSolved(index)) {
              continue;
            }
            let again = false;
            for (let j = 0; j < count; j += 1) {
              if (index === idx[cell[j]]) {
                again = true;
                break;
              }
            }
            if (again) {
              continue;
            }
            if ((candidates[index] & mask) === 0) {
              continue;
            }
            candidates[index] &= ~mask;
            changed = true;
            ht2 = idx.slice();
            ht3.push(index);
            htMask.push(mask);
          }
          if (!changed) {
            continue;
          }
          for (let i = 0; i < count; i += 1) {
            ht1.push(idx[cell[i]]);
          }
          msg = tech.Claiming;
          return true;
        }
        return false;
      }

      function p_findClaiming() {
        const c = [];
        const idx = [];
        for (let i = 0; i < 9; i += 1) {
          getCandidateListOfCol(i, c, idx);
          if (findClaiming(c, idx)) {
            return true;
          }
          getCandidateListOfRow(i, c, idx);
          if (findClaiming(c, idx)) {
            return true;
          }
        }
        return false;
      }

      function p_findPointing() {
        const c = [];
        const idx = [];
        const cell = [];
        for (let box = 0; box < 9; box += 1) {
          getCandidateListOfBox(box, c, idx);
          for (let n = 1; n <= 9; n += 1) {
            const count = getCandidateCountOfList(c, n, cell);
            if (count !== 2 && count !== 3) {
              continue;
            }
            const col = [];
            const row = [];
            for (let i = 0; i < count; i += 1) {
              const index = idx[cell[i]];
              col[i] = COL(index) % 3;
              row[i] = ROW(index) % 3;
            }
            if (count === 2) {
              col[2] = col[0];
              row[2] = row[0];
            }
            const c2 = [];
            const idx2 = [];
            if (col[0] === col[1] && col[0] === col[2]) {
              getCandidateListOfCol(COL(idx[cell[0]]), c2, idx2);
            } else if (row[0] === row[1] && row[0] === row[2]) {
              getCandidateListOfRow(ROW(idx[cell[0]]), c2, idx2);
            } else {
              continue;
            }
            let changed = false;
            const mask = n2b(n);
            for (let i = 0; i < 9; i += 1) {
              const index = idx2[i];
              if (isSolved(index)) {
                continue;
              }
              let again = false;
              for (let j = 0; j < count; j += 1) {
                if (index === idx[cell[j]]) {
                  again = true;
                  break;
                }
              }
              if (again) {
                continue;
              }
              if ((candidates[index] & mask) === 0) {
                continue;
              }
              candidates[index] &= ~mask;
              changed = true;
              ht2 = idx.slice();
              ht3.push(index);
              htMask.push(mask);
            }
            if (!changed) {
              continue;
            }
            for (let i = 0; i < count; i += 1) {
              ht1.push(idx[cell[i]]);
            }
            msg = tech.Pointing;
            return true;
          }
        }
        return false;
      }

      function findNakedSet(c, idx, n) {
        const pos = [];
        for (let mask = 0; mask < 0x1ff; mask += 1) {
          if (bc(mask) !== n) {
            continue;
          }
          let i2 = 0;
          for (let j = 0; j < 9; j += 1) {
            if (c[j] && (c[j] & ~mask) === 0) {
              pos[i2] = idx[j];
              i2 += 1;
            }
          }
          if (i2 !== n) {
            continue;
          }
          let changed = false;
          for (let j = 0; j < 9; j += 1) {
            const index = idx[j];
            if (isSolved(index)) {
              continue;
            }
            let again = false;
            for (let k = 0; k < n; k += 1) {
              if (index === pos[k]) {
                again = true;
                break;
              }
            }
            if (again) {
              continue;
            }
            if ((candidates[idx[j]] & mask) === 0) {
              continue;
            }
            htMask.push(candidates[idx[j]] & mask);
            ht3.push(idx[j]);
            candidates[idx[j]] &= ~mask;
            changed = true;
          }
          if (!changed) {
            continue;
          }
          for (let j = 0; j < n; j += 1) {
            ht1.push(pos[j]);
          }
          ht2 = idx.slice();
          msg = tech.NakedSubset;
          return true;
        }
        return false;
      }

      function findHiddenSet(c, idx, n) {
        const count = [];
        const cell = [];
        for (let i = 0; i < 9; i += 1) {
          cell[i] = [];
        }
        for (let i = 0; i < 9; i += 1) {
          count[i] = getCandidateCountOfList(c, 1 + i, cell[i]);
        }
        const set = [];
        let nset = 0;
        for (let i = 0; i < 9; i += 1) {
          if (count[i] !== 0 && count[i] <= n) {
            set[nset] = i;
            nset += 1;
          }
        }
        if (nset !== n) {
          return false;
        }
        let npos = 0;
        const pos = [];
        for (let i = 0; i < nset; i += 1) {
          for (let j = 0; j < count[set[i]]; j += 1) {
            if (npos !== 0) {
              let found = false;
              for (let k = 0; k < npos; k += 1) {
                if (pos[k] === cell[set[i]][j]) {
                  found = true;
                  break;
                }
              }
              if (!found) {
                pos[npos] = cell[set[i]][j];
                npos += 1;
              }
            } else {
              pos[npos] = cell[set[i]][j];
              npos += 1;
            }
          }
        }
        if (npos !== n) {
          return false;
        }
        let change = false;
        for (let i = 0; i < 9; i += 1) {
          const index = idx[i];
          if (isSolved(index)) {
            continue;
          }
          for (let j = 0; j < npos; j += 1) {
            if (i === pos[j]) {
              let mask = 0;
              for (let k = 0; k < nset; k += 1) {
                mask |= n2b(1 + set[k]);
              }
              const prev = candidates[index];
              candidates[index] &= mask;
              if (prev !== candidates[index]) {
                change = true;
                htMask.push(prev ^ mask);
              }
              break;
            }
          }
        }
        if (!change) {
          return false;
        }
        for (let i = 0; i < n; i += 1) {
          ht1.push(idx[pos[i]]);
        }
        ht2 = idx.slice();
        ht3 = ht1.slice();
        msg = tech.HiddenSubset;
        return true;
      }

      function p_findSubset() {
        const c = [];
        const idx = [];
        for (let n = 2; n <= 4; n += 1) {
          for (let i = 0; i < 9; i += 1) {
            getCandidateListOfBox(i, c, idx);
            if (findNakedSet(c, idx, n)) {
              return true;
            }
            getCandidateListOfCol(i, c, idx);
            if (findNakedSet(c, idx, n)) {
              return true;
            }
            getCandidateListOfRow(i, c, idx);
            if (findNakedSet(c, idx, n)) {
              return true;
            }
          }
        }
        for (let n = 2; n <= 4; n += 1) {
          for (let i = 0; i < 9; i += 1) {
            getCandidateListOfBox(i, c, idx);
            if (findHiddenSet(c, idx, n)) {
              return true;
            }
            getCandidateListOfCol(i, c, idx);
            if (findHiddenSet(c, idx, n)) {
              return true;
            }
            getCandidateListOfRow(i, c, idx);
            if (findHiddenSet(c, idx, n)) {
              return true;
            }
          }
        }
        return false;
      }

      function findXWings(isRow) {
        const c = [];
        const idx = [];
        const cell = [];
        const c2 = [];
        const idx2 = [];
        const cell2 = [];
        const c34 = [[], []];
        const idx34 = [[], []];
        for (let n = 1; n <= 9; n += 1) {
          for (let i = 0; i < 9; i += 1) {
            if (isRow) {
              getCandidateListOfRow(i, c, idx);
            } else {
              getCandidateListOfCol(i, c, idx);
            }
            if (getCandidateCountOfList(c, n, cell) !== 2) {
              continue;
            }
            for (let j = i + 1; j < 9; j += 1) {
              if (isRow) {
                getCandidateListOfRow(j, c2, idx2);
              } else {
                getCandidateListOfCol(j, c2, idx2);
              }
              if (getCandidateCountOfList(c2, n, cell2) !== 2) {
                continue;
              }
              if (cell[0] !== cell2[0] || cell[1] !== cell2[1]) {
                continue;
              }
              let changed = false;
              if (isRow) {
                getCandidateListOfCol(cell[0], c34[0], idx34[0]);
                getCandidateListOfCol(cell[1], c34[1], idx34[1]);
              } else {
                getCandidateListOfRow(cell[0], c34[0], idx34[0]);
                getCandidateListOfRow(cell[1], c34[1], idx34[1]);
              }
              for (let l = 0; l < 2; l += 1) {
                for (let k = 0; k < 9; k += 1) {
                  if (i === k || j === k || isSolved(idx34[l][k])) {
                    continue;
                  }
                  if (c34[l][k] & n2b(n)) {
                    changed = true;
                    candidates[idx34[l][k]] &= ~n2b(n);
                    ht3.push(idx34[l][k]);
                    htMask.push(n2b(n));
                  }
                }
              }
              if (!changed) {
                continue;
              }
              ht1.push(idx[cell[0]]);
              ht1.push(idx[cell[1]]);
              ht1.push(idx2[cell[0]]);
              ht1.push(idx2[cell[1]]);
              ht2 = idx.concat(idx2, idx34[0], idx34[1]);
              ht4.push(idx[cell[0]]);
              ht4.push(idx2[cell[1]]);
              ht4.push(n);
              ht4.push(idx[cell[1]]);
              ht4.push(idx2[cell[0]]);
              ht4.push(n);
              msg = tech.X_Wing;
              return true;
            }
          }
        }
        return false;
      }

      function p_findXWings() {
        return findXWings(true) || findXWings(false);
      }

      function findXyWings1() {
        for (let i = 0; i < 81; i += 1) {
          if (isSolved(i) || bc(candidates[i]) !== 2) {
            continue;
          }
          const box = BOX(i);
          const c = [];
          const idx = [];
          const c2 = [];
          const idx2 = [];
          const wings = [];
          getCandidateListOfRow(ROW(i), c, idx);
          for (let j = 0; j < 9; j += 1) {
            if (idx[j] === i || isSolved(idx[j]) || bc(c[j]) !== 2 || (c[j] & candidates[i]) === 0 || BOX(idx[j]) === box) {
              continue;
            }
            wings[0] = idx[j];
            getCandidateListOfCol(COL(i), c2, idx2);
            for (let k = 0; k < 9; k += 1) {
              if (
                idx2[k] === i ||
                isSolved(idx2[k]) ||
                bc(c2[k]) !== 2 ||
                candidates[wings[0]] !== (c2[k] ^ candidates[i]) ||
                BOX(idx2[k]) === box
              ) {
                continue;
              }
              wings[1] = idx2[k];
              if (BOX(wings[0]) === BOX(wings[1])) {
                continue;
              }
              const i3 = getIdxFromColRow(COL(wings[0]), ROW(wings[1]));
              if (isSolved(i3)) {
                continue;
              }
              const mask = candidates[wings[0]] & candidates[wings[1]];
              if ((candidates[i3] & mask) === 0) {
                continue;
              }
              candidates[i3] &= ~mask;
              ht1.push(i);
              ht1.push(wings[0]);
              ht1.push(wings[1]);
              ht3.push(i3);
              htMask.push(mask);
              msg = tech.XY_Wing;
              return true;
            }
          }
        }
        return false;
      }

      function findXyWings2() {
        const c = [];
        const idx = [];
        const c2 = [];
        const idx2 = [];
        for (let box = 0; box < 9; box += 1) {
          getCandidateListOfBox(box, c, idx);
          for (let cell = 0; cell < 9; cell += 1) {
            if (isSolved(idx[cell]) || bc(c[cell]) !== 2) {
              continue;
            }
            for (let cell2 = 0; cell2 < 9; cell2 += 1) {
              if (cell2 === cell || isSolved(idx[cell2]) || bc(c[cell2]) !== 2) {
                continue;
              }
              if ((c[cell] & c[cell2]) === 0) {
                continue;
              }
              const col = COL(idx[cell]);
              const row = ROW(idx[cell]);
              const col2 = COL(idx[cell2]);
              const row2 = ROW(idx[cell2]);
              const x = c[cell] ^ c[cell2];
              if (x === 0) {
                continue;
              }
              let i3;
              let mask;
              let changed = false;
              if (col !== col2) {
                getCandidateListOfCol(col, c2, idx2);
                for (let i = 0; i < 9; i += 1) {
                  if (isSolved(idx2[i]) || bc(c2[i]) !== 2 || c2[i] !== x || BOX(idx2[i]) === box) {
                    continue;
                  }
                  i3 = getIdxFromColRow(col, ROW(idx2[i]));
                  mask = c2[i] & c[cell2];
                  for (let j = 0; j < 9; j += 1) {
                    if (!isSolved(idx2[j]) && ROW(idx2[j]) !== row && (c2[j] & mask) !== 0 && BOX(idx2[j]) === box) {
                      changed = true;
                      candidates[idx2[j]] &= ~mask;
                      ht3.push(idx2[j]);
                      htMask.push(mask);
                    }
                  }
                  getCandidateListOfCol(col2, c2, idx2);
                  for (let j = 0; j < 9; j += 1) {
                    if (!isSolved(idx2[j]) && (c2[j] & mask) !== 0 && BOX(idx2[j]) === BOX(i3)) {
                      changed = true;
                      candidates[idx2[j]] &= ~mask;
                      ht3.push(idx2[j]);
                      htMask.push(mask);
                    }
                  }
                  break;
                }
              }
              if (!changed && row !== row2) {
                getCandidateListOfRow(row, c2, idx2);
                for (let i = 0; i < 9; i += 1) {
                  if (isSolved(idx2[i]) || bc(c2[i]) !== 2 || c2[i] !== x || BOX(idx2[i]) === box) {
                    continue;
                  }
                  i3 = getIdxFromColRow(COL(idx2[i]), row);
                  mask = c2[i] & c[cell2];
                  for (let j = 0; j < 9; j += 1) {
                    if (!isSolved(idx2[j]) && COL(idx2[j]) !== col && (c2[j] & mask) !== 0 && BOX(idx2[j]) === box) {
                      changed = true;
                      candidates[idx2[j]] &= ~mask;
                      ht3.push(idx2[j]);
                      htMask.push(mask);
                    }
                  }
                  getCandidateListOfRow(row2, c2, idx2);
                  for (let j = 0; j < 9; j += 1) {
                    if (!isSolved(idx2[j]) && (c2[j] & mask) !== 0 && BOX(idx2[j]) === BOX(i3)) {
                      changed = true;
                      candidates[idx2[j]] &= ~mask;
                      ht3.push(idx2[j]);
                      htMask.push(mask);
                    }
                  }
                  break;
                }
              }
              if (!changed) {
                continue;
              }
              ht1.push(idx[cell]);
              ht1.push(idx[cell2]);
              ht1.push(i3);
              msg = tech.XY_Wing;
              return true;
            }
          }
        }
        return false;
      }

      function p_findXyWings() {
        return findXyWings1() || findXyWings2();
      }

      function isChanged(a, b, mask) {
        let changed = false;
        const c = [];
        const idx = [];
        if (COL(a) === COL(b)) {
          getCandidateListOfCol(COL(a), c, idx);
          for (let k = 0; k < 9; k += 1) {
            if (idx[k] !== a && idx[k] !== b && !isSolved(idx[k]) && (c[k] & mask)) {
              changed = true;
              candidates[idx[k]] &= ~mask;
              ht3.push(idx[k]);
              htMask.push(mask);
            }
          }
        } else if (ROW(a) === ROW(b)) {
          getCandidateListOfRow(ROW(a), c, idx);
          for (let k = 0; k < 9; k += 1) {
            if (idx[k] !== a && idx[k] !== b && !isSolved(idx[k]) && (c[k] & mask)) {
              changed = true;
              candidates[idx[k]] &= ~mask;
              ht3.push(idx[k]);
              htMask.push(mask);
            }
          }
        } else {
          getCandidateListOfBox(BOX(a), c, idx);
          for (let k = 0; k < 9; k += 1) {
            if (
              idx[k] !== a &&
              !isSolved(idx[k]) &&
              (c[k] & mask) &&
              (ROW(b) === ROW(idx[k]) || COL(b) === COL(idx[k]))
            ) {
              changed = true;
              candidates[idx[k]] &= ~mask;
              ht3.push(idx[k]);
              htMask.push(mask);
            }
          }
          getCandidateListOfBox(BOX(b), c, idx);
          for (let k = 0; k < 9; k += 1) {
            if (
              idx[k] !== b &&
              !isSolved(idx[k]) &&
              (c[k] & mask) &&
              (ROW(a) === ROW(idx[k]) || COL(a) === COL(idx[k]))
            ) {
              changed = true;
              candidates[idx[k]] &= ~mask;
              ht3.push(idx[k]);
              htMask.push(mask);
            }
          }
          const ix1 = getIdxFromColRow(COL(a), ROW(b));
          if (!isSolved(ix1) && (candidates[ix1] & mask)) {
            changed = true;
            candidates[ix1] &= ~mask;
            ht3.push(ix1);
            htMask.push(mask);
          }
          const ix2 = getIdxFromColRow(COL(b), ROW(a));
          if (!isSolved(ix2) && (candidates[ix2] & mask)) {
            changed = true;
            candidates[ix2] &= ~mask;
            ht3.push(ix2);
            htMask.push(mask);
          }
        }
        return changed;
      }

      function findWWings(c, idx, i1, i2) {
        const r1 = ROW(i1);
        const c1 = COL(i1);
        const r2 = ROW(i2);
        const c2 = COL(i2);
        if (r1 === r2 || c1 === c2) {
          return false;
        }
        const cell = [];
        for (let i = 0; i < 9; i += 1) {
          if ((n2b(1 + i) & candidates[i1]) === 0) {
            continue;
          }
          if (getCandidateCountOfList(c, 1 + i, cell) !== 2) {
            continue;
          }
          if (
            idx[cell[0]] === i1 ||
            idx[cell[0]] === i2 ||
            idx[cell[1]] === i1 ||
            idx[cell[1]] === i2
          ) {
            continue;
          }
          const lr1 = ROW(idx[cell[0]]);
          const lc1 = COL(idx[cell[0]]);
          const lr2 = ROW(idx[cell[1]]);
          const lc2 = COL(idx[cell[1]]);
          if (
            (r1 !== lr1 || r2 !== lr2) &&
            (c1 !== lc1 || c2 !== lc2) &&
            (r1 !== lr2 || r2 !== lr1) &&
            (c1 !== lc2 || c2 !== lc1)
          ) {
            continue;
          }
          if (!isChanged(i1, i2, candidates[i1] & ~n2b(1 + i))) {
            continue;
          }
          ht1.push(i1);
          ht1.push(i2);
          ht2.push(getIdxFromColRow(lc1, lr1));
          ht2.push(getIdxFromColRow(lc2, lr2));
          msg = tech.W_Wing;
          return true;
        }
        return false;
      }

      function p_findWWings() {
        for (let i = 0; i < 81; i += 1) {
          if (isSolved(i) || bc(candidates[i]) !== 2) {
            continue;
          }
          const box1 = BOX(i);
          for (let j = i + 1; j < 81; j += 1) {
            if (isSolved(j) || candidates[i] !== candidates[j]) {
              continue;
            }
            const box2 = BOX(j);
            if (box1 === box2) {
              continue;
            }
            const c = [];
            const idx = [];
            for (let k = 0; k < 9; k += 1) {
              getCandidateListOfCol(k, c, idx);
              if (findWWings(c, idx, i, j)) {
                return true;
              }
              getCandidateListOfRow(k, c, idx);
              if (findWWings(c, idx, i, j)) {
                return true;
              }
              getCandidateListOfBox(k, c, idx);
              if (findWWings(c, idx, i, j)) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function findXyzWings(c, idx, box, isRow, rowcol, i1, i2, c1, c2, mask) {
        const x = c1 ^ c2;
        let changed = false;
        let pivot = -1;
        for (let i = 0; i < 9; i += 1) {
          if (
            isSolved(idx[i]) ||
            bc(c[i]) !== 2 ||
            (c[i] & x) === 0 ||
            (c1 & c[i]) === 0 ||
            bc(c1 & c[i]) !== 2 ||
            BOX(idx[i]) === box
          ) {
            continue;
          }
          pivot = idx[i];
          mask = c[i] & c2;
          for (let j = 0; j < 9; j += 1) {
            if (
              !isSolved(idx[j]) &&
              i1 !== idx[j] &&
              i2 !== idx[j] &&
              ((isRow && ROW(idx[j]) !== rowcol) || (!isRow && COL(idx[j]) !== rowcol)) &&
              (c[j] & mask) !== 0 &&
              BOX(idx[j]) === box
            ) {
              changed = true;
              candidates[idx[j]] &= ~mask;
              ht3.push(idx[j]);
              htMask.push(mask);
            }
          }
          break;
        }
        return changed ? pivot : -1;
      }

      function p_findXyzWings() {
        const c = [];
        const idx = [];
        const c2 = [];
        const idx2 = [];
        for (let box = 0; box < 9; box += 1) {
          getCandidateListOfBox(box, c, idx);
          for (let cell = 0; cell < 9; cell += 1) {
            if (isSolved(idx[cell]) || bc(c[cell]) !== 3) {
              continue;
            }
            for (let cell2 = 0; cell2 < 9; cell2 += 1) {
              if (cell2 === cell || isSolved(idx[cell2]) || bc(c[cell2]) !== 2) {
                continue;
              }
              if ((c[cell] & c[cell2]) === 0 || bc(c[cell] & c[cell2]) !== 2) {
                continue;
              }
              const col = COL(idx[cell]);
              const row = ROW(idx[cell]);
              const col2 = COL(idx[cell2]);
              const row2 = ROW(idx[cell2]);
              if ((c[cell] ^ c[cell2]) === 0) {
                continue;
              }
              let pivot = -1;
              let mask = 0;
              if (col !== col2) {
                getCandidateListOfCol(col, c2, idx2);
                pivot = findXyzWings(c2, idx2, box, true, row, idx[cell], idx[cell2], c[cell], c[cell2], mask);
              }
              if (pivot === -1 && row !== row2) {
                getCandidateListOfRow(row, c2, idx2);
                pivot = findXyzWings(c2, idx2, box, false, col, idx[cell], idx[cell2], c[cell], c[cell2], mask);
              }
              if (pivot === -1) {
                continue;
              }
              ht1.push(idx[cell]);
              ht1.push(idx[cell2]);
              ht1.push(pivot);
              msg = tech.XYZ_Wing;
              return true;
            }
          }
        }
        return false;
      }

      function hasLink(a, b) {
        return BOX(a) === BOX(b) || COL(a) === COL(b) || ROW(a) === ROW(b);
      }

      function p_findXChains() {
        const c = [];
        const idx = [];
        const cell = [];
        const chainCandidates = [];
        for (let n = 1; n <= 9; n += 1) {
          let cx = 0;
          for (let row = 0; row < 9; row += 1) {
            getCandidateListOfRow(row, c, idx);
            if (getCandidateCountOfList(c, n, cell) === 2) {
              const i1 = idx[cell[0]];
              const i2 = idx[cell[1]];
              if (BOX(i1) !== BOX(i2)) {
                chainCandidates[cx * 2] = i1;
                chainCandidates[cx * 2 + 1] = i2;
                cx += 1;
              }
            }
          }
          for (let col = 0; col < 9; col += 1) {
            getCandidateListOfCol(col, c, idx);
            if (getCandidateCountOfList(c, n, cell) === 2) {
              const i1 = idx[cell[0]];
              const i2 = idx[cell[1]];
              if (BOX(i1) !== BOX(i2)) {
                chainCandidates[cx * 2] = i1;
                chainCandidates[cx * 2 + 1] = i2;
                cx += 1;
              }
            }
          }
          for (let box = 0; box < 9; box += 1) {
            getCandidateListOfBox(box, c, idx);
            if (getCandidateCountOfList(c, n, cell) === 2) {
              chainCandidates[cx * 2] = idx[cell[0]];
              chainCandidates[cx * 2 + 1] = idx[cell[1]];
              cx += 1;
            }
          }
          if (cx < 2) {
            continue;
          }
          for (let i = 0; i < cx; i += 1) {
            let len = 0;
            const chain = [];
            const linked = new Array(cx).fill(false);
            let a = chainCandidates[i * 2];
            let b = chainCandidates[i * 2 + 1];
            linked[i] = true;
            chain[len] = i;
            len += 1;
            while (true) {
              const previousLen = len;
              for (let j = 0; j < cx; j += 1) {
                let gotNewLink = false;
                if (linked[j]) {
                  continue;
                }
                const ci = chainCandidates[j * 2];
                const d = chainCandidates[j * 2 + 1];
                let dup = false;
                for (let k = 0; k < len; k += 1) {
                  if (
                    ci === chainCandidates[2 * chain[k]] ||
                    d === chainCandidates[2 * chain[k]] ||
                    ci === chainCandidates[2 * chain[k] + 1] ||
                    d === chainCandidates[2 * chain[k] + 1]
                  ) {
                    dup = true;
                    break;
                  }
                }
                if (dup) {
                  continue;
                }
                if (hasLink(a, ci) && BOX(b) !== BOX(d)) {
                  a = d;
                  gotNewLink = true;
                } else if (hasLink(a, d) && BOX(b) !== BOX(ci)) {
                  a = ci;
                  gotNewLink = true;
                } else if (hasLink(b, ci) && BOX(a) !== BOX(d)) {
                  b = d;
                  gotNewLink = true;
                } else if (hasLink(b, d) && BOX(a) !== BOX(ci)) {
                  b = ci;
                  gotNewLink = true;
                }
                if (!gotNewLink) {
                  continue;
                }
                linked[j] = true;
                chain[len] = j;
                len += 1;
                if (!isChanged(a, b, n2b(n))) {
                  continue;
                }
                ht1.push(a);
                ht1.push(b);
                for (let k = 0; k < len; k += 1) {
                  ht4.push(chainCandidates[2 * chain[k]]);
                  ht4.push(chainCandidates[2 * chain[k] + 1]);
                  ht4.push(n);
                }
                msg = tech.X_Chains;
                return true;
              }
              if (len === previousLen) {
                break;
              }
            }
          }
        }
        return false;
      }

      function c2b(c, n) {
        for (let i = 0, mask = 1; i < 9; i += 1, mask <<= 1) {
          if (c & mask && --n === 0) {
            return mask;
          }
        }
        return 0;
      }

      let xyMask = 0;
      let xyNCell = 0;
      const xyCell = [];
      const xyFlag = [];
      let xyNChain = 0;
      const xyChain = [];

      function findXyChains(link) {
        if (xyNChain > 2 && link === xyMask) {
          const a = xyChain[0];
          const b = xyChain[xyNChain - 1];
          if ((candidates[b] & xyMask) !== 0 && isChanged(a, b, xyMask)) {
            ht1.push(a);
            ht1.push(b);
            let mask = xyMask;
            for (let i = 0; i < xyNChain - 1; i += 1) {
              ht4.push(xyChain[i]);
              ht4.push(xyChain[i + 1]);
              const c = candidates[xyChain[i]];
              const l1 = c2b(c, 1);
              const l2 = c2b(c, 2);
              let mask1 = l1 === mask ? l2 : l1;
              if (mask1 === 0) {
                const cNext = candidates[xyChain[i + 1]];
                const lNext1 = c2b(cNext, 1);
                const lNext2 = c2b(cNext, 2);
                mask1 = lNext1 === mask ? lNext2 : lNext1;
              }
              ht4.push(b2n(mask1));
              mask = mask1;
            }
            msg = tech.XY_Chains;
            return true;
          }
        }
        for (let i = 0; i < xyNCell; i += 1) {
          if (xyFlag[i]) {
            continue;
          }
          const cell = xyCell[i];
          if (!hasLink(xyChain[xyNChain - 1], cell)) {
            continue;
          }
          const c = candidates[cell];
          if ((c & link) === 0) {
            continue;
          }
          xyFlag[i] = true;
          xyChain[xyNChain] = cell;
          xyNChain += 1;
          const link1 = c2b(c, 1);
          const link2 = c2b(c, 2);
          if (link === link1) {
            if (findXyChains(link2)) {
              return true;
            }
          } else if (findXyChains(link1)) {
            return true;
          }
          xyFlag[i] = false;
          xyNChain -= 1;
        }
        return false;
      }

      function p_findXyChains() {
        xyNCell = 0;
        xyNChain = 0;
        for (let i = 0; i < 81; i += 1) {
          if (bc(candidates[i]) === 2) {
            xyCell[xyNCell] = i;
            xyFlag[xyNCell] = false;
            xyNCell += 1;
          }
        }
        for (let i = 0; i < xyNCell; i += 1) {
          xyFlag[i] = true;
          const cell = xyCell[i];
          xyChain[xyNChain] = cell;
          xyNChain += 1;
          const c = candidates[cell];
          const link1 = c2b(c, 1);
          const link2 = c2b(c, 2);
          xyMask = link2;
          if (findXyChains(link1)) {
            return true;
          }
          xyMask = link1;
          if (findXyChains(link2)) {
            return true;
          }
          xyFlag[i] = false;
          xyNChain -= 1;
        }
        return false;
      }

      const pattern = [
        p_findSingle,
        p_findClaiming,
        p_findPointing,
        p_findSubset,
        p_findXWings,
        p_findXyWings,
        p_findWWings,
        p_findXyzWings,
        p_findXChains,
        p_findXyChains,
      ];

      function isBoardSolved() {
        for (let i = 0; i < 81; i += 1) {
          if (!isSolved(i)) {
            return false;
          }
        }
        return true;
      }

      function clearSteps() {
        stepsContainer.innerHTML = "";
      }

      function renderMain() {
        renderPuzzle("board", { selection: editMode ? selectedCell : null });
        updateStatus();
        updateDigitPanel();
      }

      function updateStatus() {
        if (editMode) {
          statusText.textContent = "编辑模式：可以点击棋盘录入题目。";
        } else if (isBoardSolved()) {
          statusText.textContent = "演示模式：数独已全部解出。";
        } else {
          statusText.textContent = "演示模式：继续执行单步或自动求解。";
        }
      }

      function updateDigitPanel() {
        digitPanel.hidden = !(editMode && selectedCell !== null);
      }

      function resetPuzzle() {
        for (let i = 0; i < 81; i += 1) {
          puzzle[i] = 0;
        }
        initCandidates();
        clearSteps();
        shareInput.value = "";
        editMode = true;
        selectedCell = null;
        renderMain();
      }

      function applyPuzzle(values) {
        for (let i = 0; i < 81; i += 1) {
          puzzle[i] = values[i] || 0;
        }
        initCandidates();
        clearSteps();
        editMode = true;
        selectedCell = null;
        shareInput.value = "";
        renderMain();
      }

      function parsePuzzleText(text) {
        const cleaned = text.replace(/[^0-9.]/g, "");
        const values = new Array(81).fill(0);
        for (let i = 0; i < 81 && i < cleaned.length; i += 1) {
          const ch = cleaned[i];
          values[i] = ch === "." ? 0 : Number(ch) || 0;
        }
        return values;
      }

      function exportPuzzleText() {
        return puzzle.map((n) => (n === 0 ? "." : String(n))).join("");
      }

      function executeSolver({ auto }) {
        if (editMode) {
          editMode = false;
          selectedCell = null;
        }
        updateStatus();
        updateDigitPanel();

        let applied = false;
        let round = stepsContainer.childElementCount + 1;

        const tryApply = () => {
          for (const technique of pattern) {
            if (technique()) {
              updateCandidates();
              addStep(round);
              round += 1;
              applied = true;
              return true;
            }
          }
          return false;
        };

        if (auto) {
          while (tryApply()) {
            // 持续执行直到没有新的推理
          }
        } else {
          tryApply();
        }

        renderMain();
        return applied;
      }

      function generateShareLink() {
        const base = window.location.origin + window.location.pathname;
        const params = new URLSearchParams();
        params.set("p", puzzle.join(","));
        if (!editMode) {
          params.set("s", "1");
        }
        return base + "?" + params.toString();
      }

      function applyExample() {
        const example = "530070000600195000098000060800060003400803001700020006060000280000419005000080079";
        applyPuzzle(parsePuzzleText(example));
        puzzleInput.value = example;
      }

      function loadFromQuery() {
        const params = new URLSearchParams(window.location.search);
        if (!params.has("p")) {
          resetPuzzle();
          return;
        }
        const raw = params.get("p") || "";
        let values = [];
        if (raw.includes(",")) {
          values = raw.split(",").map((v) => Number(v) || 0);
        } else {
          values = parsePuzzleText(raw);
        }
        values.length = 81;
        for (let i = 0; i < 81; i += 1) {
          values[i] = values[i] || 0;
        }
        applyPuzzle(values);
        puzzleInput.value = exportPuzzleText();
        editMode = params.get("s") === "1" ? false : true;
        selectedCell = null;
        updateStatus();
        updateDigitPanel();
      }

      function toggleEditMode() {
        editMode = true;
        selectedCell = null;
        updateStatus();
        updateDigitPanel();
        renderMain();
      }

      boardCanvas.addEventListener("click", (event) => {
        if (!editMode) {
          return;
        }
        const rect = boardCanvas.getBoundingClientRect();
        const scaleX = boardCanvas.width / rect.width;
        const scaleY = boardCanvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX;
        const y = (event.clientY - rect.top) * scaleY;
        const col = Math.floor(x / (1 + CELL_W));
        const row = Math.floor(y / (1 + CELL_H));
        if (col < 0 || col >= 9 || row < 0 || row >= 9) {
          return;
        }
        selectedCell = getIdxFromColRow(col, row);
        updateDigitPanel();
        renderMain();
      });

      digitPanel.addEventListener("click", (event) => {
        const button = event.target.closest("button");
        if (!button || selectedCell === null || !editMode) {
          return;
        }
        const digit = Number(button.dataset.digit);
        puzzle[selectedCell] = digit;
        initCandidates();
        renderMain();
      });

      document.getElementById("btn-reset").addEventListener("click", () => {
        resetPuzzle();
        puzzleInput.value = "";
      });

      document.getElementById("btn-example").addEventListener("click", () => {
        applyExample();
      });

      document.getElementById("btn-edit").addEventListener("click", () => {
        toggleEditMode();
      });

      document.getElementById("btn-step").addEventListener("click", () => {
        if (!executeSolver({ auto: false })) {
          statusText.textContent = "没有可用的进一步推理。";
        }
      });

      document.getElementById("btn-solve").addEventListener("click", () => {
        if (!executeSolver({ auto: true })) {
          statusText.textContent = "没有可用的进一步推理。";
        }
      });

      document.getElementById("btn-step-clear").addEventListener("click", () => {
        clearSteps();
      });

      document.getElementById("btn-share").addEventListener("click", () => {
        shareInput.value = generateShareLink();
        shareInput.focus();
        shareInput.select();
      });

      document.getElementById("btn-apply").addEventListener("click", () => {
        const values = parsePuzzleText(puzzleInput.value);
        applyPuzzle(values);
      });

      document.getElementById("btn-export").addEventListener("click", () => {
        puzzleInput.value = exportPuzzleText();
        puzzleInput.focus();
        puzzleInput.select();
      });

      window.addEventListener("keydown", (event) => {
        if (!editMode || selectedCell === null) {
          return;
        }
        if (/^[0-9]$/.test(event.key)) {
          puzzle[selectedCell] = Number(event.key);
          initCandidates();
          renderMain();
          event.preventDefault();
        } else if (event.key === "Backspace" || event.key === "Delete") {
          puzzle[selectedCell] = 0;
          initCandidates();
          renderMain();
          event.preventDefault();
        } else if (event.key.startsWith("Arrow")) {
          const row = ROW(selectedCell);
          const col = COL(selectedCell);
          if (event.key === "ArrowUp" && row > 0) {
            selectedCell -= 9;
          } else if (event.key === "ArrowDown" && row < 8) {
            selectedCell += 9;
          } else if (event.key === "ArrowLeft" && col > 0) {
            selectedCell -= 1;
          } else if (event.key === "ArrowRight" && col < 8) {
            selectedCell += 1;
          } else {
            return;
          }
          updateDigitPanel();
          renderMain();
          event.preventDefault();
        }
      });

      loadFromQuery();
      renderMain();
    })();
  </script>
</body>
</html>
